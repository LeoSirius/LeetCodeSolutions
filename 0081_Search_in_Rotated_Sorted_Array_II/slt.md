### 思路1 只对有序的那一半进行二分查找

与33 Search in Rotated Sorted Array I不同，这道题可能包含重复的元素

必须跳过重复的元素。不然像{1,3,1,1,1}这种过不了



C++最简洁的二分法分类讨论
每次二分，左半部分和右半部分至少有一边是有序的，以此为条件可以分成两种情况：
1、左半边是有序的
(1) target落在左半边
(2) otherwise
2、右半边是有序的
(1) target落在右半边
(2) otherwise
综上所述，一共两种可能性，这两种情况各自又有两种可能性
