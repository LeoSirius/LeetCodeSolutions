### 思路1 dp

dp[i]表示到第i花费最小

可能一次走一步，也可能是两步，所以有：

- dp[i] = min(dp[i-1], dp[i-2]) + dp[i]

另外有初识条件：

dp[0] = cost[0]
dp[1] = cost[1]

最后返回

min(dp[-1], dp[-2])，跳到最后一层也有两种方式。

最后可以直接利用原数组做dp，空间复杂度O(1)
